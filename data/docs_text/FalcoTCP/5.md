Currently, it has only a single connection handler written in Rust. However, I plan to implement it for both Python and Go in the future — Python first, then Go.


# Rust

## Installing
To use the rust's implementation of FalcoTCP in your project you must add falcotcp in your Cargo.toml or use

```cargo add falcotcp```
## Features
In the falcotcp package, features alter the runtime being used on both client and server implementations. The features available are:

- tokio-runtime
- async-std-runtime
- thread (default)

```
[package]
name = "testingfalcotcp"
version = "0.1.0"
edition = "2024"
```
```
[dependencies]
falcotcp = { version="0.1.0", default-features = false, features = ["tokio-runtime"] }
```
**the property "default-features" is required when using a runtime different from the default one (thread)**
## Server
To implement server import the structure Server and create it giving the needed parameters, but be aware that the server instance is executed the time it is created, which means that the Server::new also runs the server.

- host: String

- password: [u8;32]

- message_handler: Box<dyn Fn(Vec<u8>) -> Vec<u8> + Send + Sync + 'static>
```
/*
This is an example of server initialization using the default run time (std::thread based)
*/
use falcotcp::Server;

const EXAMPLE_PASSWORD: [u8; 32] = [
    0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x5F,
    0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64,
    0x5F, 0x31, 0x32, 0x33, 0x21, 0x40, 0x23, 0x24,
    0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B,
];

fn main(){
    let message_handler = Box::new(|parameter : Vec<u8>| {
        parameter // This function simply echoes the parameter; any logic involving it must be handled here.
    });
    if let Err(e) = Server::new(
        "127.0.0.1:8000".to_string(), // host 
        EXAMPLE_PASSWORD, // password
        message_handler, // message handler (function in which apply logic towards the input and returns a Vec<u8> as output)
        2 // workers count
    ){
        eprintln!("Failed to start server: {:?}",e);
    };
}
```
## Client
The client, on the other hand, does not start directly as the Client. It is non-blocking and waits for a response to reach you. However, you must ensure that the password matches the server's; otherwise, the connection will be terminated. There is no graceful error handling, as the protocol assumes you are properly managing both the Server and the Client.

To start the connection, use the Client::new implementation, which takes the server's address and the password as parameters. Once connected, you can send messages to the server and ping it.

Keep in mind that the connection lasts only 60 seconds. If you don’t send a message or a ping within that time, the server will shut it down. It’s recommended to ping the server every 30 seconds to keep the connection alive.

- password: [u8;32]
- address: &str
- timeout: u64 (only on the feature thread)


```
/*
This is an example of client initialization using the default run time (std::thread based)
*/
use falcotcp::Server;

const EXAMPLE_PASSWORD: [u8; 32] = [
    0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x5F,
    0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64,
    0x5F, 0x31, 0x32, 0x33, 0x21, 0x40, 0x23, 0x24,
    0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B,
];

fn main(){
    match Client::new("127.0.0.1:8000", EXAMPLE_PASSWORD) {
        Ok(mut client) => {
            match client.message(vec![8u8; 10]) { // Sends 10 bytes to the server
                Ok(response) => {
                    println!("{:?}",response); // print the byte response
                },
                Err(e) => {
                    eprintln!("err:{:?}",e);
                }
            }
        },
        Err(e) => {
            eprintln!("failed to initialize:{:?}",e);
        }
    }
}
```